//! Timeline types for editing decisions.
//!
//! A timeline contains keyframes and effects that describe how to
//! transform raw source material into the final output. Timelines
//! are generated by the Auto-Director and can be manually adjusted.

use serde::{Deserialize, Serialize};

use crate::viewport::Viewport;

/// The complete editing timeline for a project.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Timeline {
    /// Schema version for forward compatibility.
    pub version: String,

    /// Camera keyframes controlling zoom/pan over time.
    pub keyframes: Vec<CameraKeyframe>,

    /// Effects applied to the output.
    pub effects: Vec<Effect>,

    /// Cursor styling configuration.
    #[serde(default)]
    pub cursor_config: CursorConfig,

    /// Segments to trim/cut from the recording.
    #[serde(default)]
    pub cuts: Vec<CutSegment>,
}

/// A single camera keyframe at a specific time.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct CameraKeyframe {
    /// Time in seconds from recording start.
    #[serde(rename = "t")]
    pub time_secs: f64,

    /// The viewport at this keyframe.
    pub viewport: Viewport,

    /// Easing function for transition to the next keyframe.
    #[serde(default)]
    pub easing: EasingFunction,

    /// Whether this keyframe was auto-generated or manually placed.
    #[serde(default)]
    pub source: KeyframeSource,
}

/// Easing function for transitions between keyframes.
#[derive(Debug, Clone, Copy, Default, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum EasingFunction {
    Linear,
    EaseIn,
    EaseOut,
    #[default]
    EaseInOut,
}

impl EasingFunction {
    /// Apply the easing function to a linear `t` in [0, 1].
    pub fn apply(&self, t: f64) -> f64 {
        let t = t.clamp(0.0, 1.0);
        match self {
            EasingFunction::Linear => t,
            EasingFunction::EaseIn => t * t,
            EasingFunction::EaseOut => 1.0 - (1.0 - t).powi(2),
            EasingFunction::EaseInOut => {
                if t < 0.5 {
                    2.0 * t * t
                } else {
                    1.0 - (-2.0 * t + 2.0).powi(2) / 2.0
                }
            }
        }
    }
}

/// Origin of a keyframe.
#[derive(Debug, Clone, Copy, Default, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum KeyframeSource {
    #[default]
    Auto,
    Manual,
}

/// An effect applied during rendering.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum Effect {
    /// Cursor motion smoothing.
    CursorSmooth {
        /// Smoothing strength [0.0, 1.0].
        strength: f64,
    },

    /// Click highlight effect.
    ClickHighlight {
        /// Highlight color as hex string.
        color: String,
        /// Highlight radius in normalized units.
        radius: f64,
        /// Duration of the highlight animation in seconds.
        duration_secs: f64,
    },

    /// Subtitle burn-in.
    Subtitles {
        /// Path to subtitle file (relative to project).
        path: String,
        /// Font size in points.
        font_size: u32,
    },
}

/// Cursor rendering configuration.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CursorConfig {
    /// Smoothing algorithm.
    pub smoothing: SmoothingAlgorithm,

    /// Smoothing factor [0.0, 1.0]. Higher = more smoothing.
    pub smoothing_factor: f64,

    /// Cursor size multiplier (1.0 = default).
    pub size_multiplier: f64,

    /// Custom cursor asset path (None = default cursor).
    pub custom_asset: Option<String>,

    /// Whether to show click animations.
    pub show_click_animation: bool,
}

impl Default for CursorConfig {
    fn default() -> Self {
        Self {
            smoothing: SmoothingAlgorithm::Ema,
            smoothing_factor: 0.3,
            size_multiplier: 1.0,
            custom_asset: None,
            show_click_animation: true,
        }
    }
}

/// Smoothing algorithm for cursor motion.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum SmoothingAlgorithm {
    /// Exponential Moving Average — simple and effective.
    Ema,
    /// Bézier curve interpolation — smoother paths.
    Bezier,
    /// Kalman filter — best for noisy input.
    Kalman,
    /// No smoothing (raw data).
    None,
}

/// A segment to cut/trim from the recording.
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct CutSegment {
    /// Start time in seconds.
    pub start_secs: f64,
    /// End time in seconds.
    pub end_secs: f64,
    /// Reason for the cut.
    #[serde(default)]
    pub reason: CutReason,
}

/// Why a segment was cut.
#[derive(Debug, Clone, Copy, Default, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum CutReason {
    #[default]
    Manual,
    Silence,
    Idle,
}

impl Timeline {
    /// Create a new empty timeline.
    pub fn new() -> Self {
        Self {
            version: "1.0".to_string(),
            keyframes: vec![CameraKeyframe {
                time_secs: 0.0,
                viewport: Viewport::FULL,
                easing: EasingFunction::default(),
                source: KeyframeSource::Auto,
            }],
            effects: vec![],
            cursor_config: CursorConfig::default(),
            cuts: vec![],
        }
    }

    /// Get the interpolated viewport at a given time.
    pub fn viewport_at(&self, time_secs: f64) -> Viewport {
        if self.keyframes.is_empty() {
            return Viewport::FULL;
        }

        // If there are multiple keyframes at exactly the same timestamp,
        // prefer the last one (latest edit wins).
        if let Some(exact) = self
            .keyframes
            .iter()
            .rfind(|kf| (kf.time_secs - time_secs).abs() < 1e-9)
        {
            return exact.viewport;
        }

        // Before first keyframe
        if time_secs <= self.keyframes[0].time_secs {
            return self.keyframes[0].viewport;
        }

        // After last keyframe
        if time_secs >= self.keyframes.last().unwrap().time_secs {
            return self.keyframes.last().unwrap().viewport;
        }

        // Find surrounding keyframes
        for i in 0..self.keyframes.len() - 1 {
            let kf_a = &self.keyframes[i];
            let kf_b = &self.keyframes[i + 1];

            if time_secs >= kf_a.time_secs && time_secs <= kf_b.time_secs {
                let duration = kf_b.time_secs - kf_a.time_secs;
                if duration < 1e-9 {
                    continue;
                }
                let linear_t = (time_secs - kf_a.time_secs) / duration;
                let eased_t = kf_a.easing.apply(linear_t);
                return Viewport::lerp(&kf_a.viewport, &kf_b.viewport, eased_t);
            }
        }

        Viewport::FULL
    }

    /// Total duration based on the last keyframe.
    pub fn duration_secs(&self) -> f64 {
        self.keyframes.last().map(|kf| kf.time_secs).unwrap_or(0.0)
    }

    /// Add a keyframe, maintaining chronological order.
    pub fn add_keyframe(&mut self, keyframe: CameraKeyframe) {
        let pos = self
            .keyframes
            .binary_search_by(|kf| kf.time_secs.partial_cmp(&keyframe.time_secs).unwrap())
            .unwrap_or_else(|pos| pos);
        self.keyframes.insert(pos, keyframe);
    }

    /// Check if a time falls within a cut segment.
    pub fn is_cut(&self, time_secs: f64) -> bool {
        self.cuts
            .iter()
            .any(|cut| time_secs >= cut.start_secs && time_secs <= cut.end_secs)
    }
}

impl Default for Timeline {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_new_timeline_has_full_viewport() {
        let tl = Timeline::new();
        assert_eq!(tl.keyframes.len(), 1);
        assert_eq!(tl.keyframes[0].viewport, Viewport::FULL);
    }

    #[test]
    fn test_viewport_interpolation() {
        let mut tl = Timeline::new();
        tl.keyframes.clear();
        tl.keyframes.push(CameraKeyframe {
            time_secs: 0.0,
            viewport: Viewport::FULL,
            easing: EasingFunction::Linear,
            source: KeyframeSource::Auto,
        });
        tl.keyframes.push(CameraKeyframe {
            time_secs: 10.0,
            viewport: Viewport::new(0.25, 0.25, 0.5, 0.5),
            easing: EasingFunction::Linear,
            source: KeyframeSource::Auto,
        });

        let mid = tl.viewport_at(5.0);
        assert!((mid.x - 0.125).abs() < 1e-9);
        assert!((mid.w - 0.75).abs() < 1e-9);
    }

    #[test]
    fn test_viewport_before_first_keyframe() {
        let tl = Timeline::new();
        let vp = tl.viewport_at(-1.0);
        assert_eq!(vp, Viewport::FULL);
    }

    #[test]
    fn test_add_keyframe_maintains_order() {
        let mut tl = Timeline::new();
        tl.add_keyframe(CameraKeyframe {
            time_secs: 5.0,
            viewport: Viewport::new(0.1, 0.1, 0.8, 0.8),
            easing: EasingFunction::EaseInOut,
            source: KeyframeSource::Manual,
        });
        tl.add_keyframe(CameraKeyframe {
            time_secs: 2.0,
            viewport: Viewport::new(0.2, 0.2, 0.6, 0.6),
            easing: EasingFunction::EaseIn,
            source: KeyframeSource::Auto,
        });

        let times: Vec<f64> = tl.keyframes.iter().map(|kf| kf.time_secs).collect();
        assert!(times.windows(2).all(|w| w[0] <= w[1]));
    }

    #[test]
    fn test_easing_functions() {
        assert!((EasingFunction::Linear.apply(0.5) - 0.5).abs() < 1e-9);
        assert!(EasingFunction::EaseIn.apply(0.5) < 0.5);
        assert!(EasingFunction::EaseOut.apply(0.5) > 0.5);
        assert!((EasingFunction::EaseInOut.apply(0.0)).abs() < 1e-9);
        assert!((EasingFunction::EaseInOut.apply(1.0) - 1.0).abs() < 1e-9);
    }

    #[test]
    fn test_cut_detection() {
        let mut tl = Timeline::new();
        tl.cuts.push(CutSegment {
            start_secs: 5.0,
            end_secs: 8.0,
            reason: CutReason::Silence,
        });
        assert!(!tl.is_cut(4.0));
        assert!(tl.is_cut(6.0));
        assert!(!tl.is_cut(9.0));
    }

    #[test]
    fn test_timeline_serialization() {
        let tl = Timeline::new();
        let json = serde_json::to_string_pretty(&tl).unwrap();
        let parsed: Timeline = serde_json::from_str(&json).unwrap();
        assert_eq!(parsed.version, "1.0");
        assert_eq!(parsed.keyframes.len(), 1);
    }

    #[test]
    fn test_viewport_at_prefers_last_duplicate_timestamp() {
        let mut tl = Timeline::new();
        tl.keyframes.clear();
        tl.keyframes.push(CameraKeyframe {
            time_secs: 0.0,
            viewport: Viewport::FULL,
            easing: EasingFunction::Linear,
            source: KeyframeSource::Auto,
        });
        tl.keyframes.push(CameraKeyframe {
            time_secs: 0.0,
            viewport: Viewport::new(0.2, 0.2, 0.6, 0.6),
            easing: EasingFunction::Linear,
            source: KeyframeSource::Manual,
        });

        let vp = tl.viewport_at(0.0);
        assert_eq!(vp, Viewport::new(0.2, 0.2, 0.6, 0.6));
    }
}
